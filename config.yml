custom: {}

hub:
  service:
    type: ClusterIP
    annotations: {}
    ports:
      nodePort:
    loadBalancerIP:
  baseUrl: /
  cookieSecret:
  publicURL:
  uid: 1000
  fsGid: 1000
  nodeSelector: {}
  concurrentSpawnLimit: 64
  consecutiveFailureLimit: 5
  activeServerLimit:
  deploymentStrategy:
    # sqlite-pvc backed hub requires Recreate strategy to work
    type: Recreate
    # This is required for upgrading to work
    rollingUpdate:
  db:
    type: sqlite-pvc
    upgrade:
    pvc:
      annotations: {}
      selector: {}
      accessModes:
        - ReadWriteOnce
      storage: 1Gi
      subPath:
      storageClassName:
    url:
    password:
  labels: {}
  annotations: {}
  extraConfig:
    00-auth-config: |
      import os
      import socket
      import subprocess
      import requests
      import json
      import logging
      from jupyterhub.spawner import Spawner

      logger = logging.getLogger()
      logger.setLevel(logging.DEBUG)

      c.JupyterHub.spawner_class = 'kubespawner.KubeSpawner'
      c.JupyterHub.cleanup_servers = False

      c.JupyterHub.authenticator_class = 'ldapauthenticator.LDAPAuthenticator'
      c.LDAPAuthenticator.server_address = 'ldaps://10.25.1.6:636'
      c.LDAPAuthenticator.bind_dn_template = [
        'cn={username},ou=IMA16,ou=IMA,OU=Studenten,OU=Benutzer,OU=Graz,OU=Technikum,dc=technikum,dc=fh-joanneum,dc=local',
        'cn={username},ou=IMA18,ou=IMA,OU=Studenten,OU=Benutzer,OU=Graz,OU=Technikum,dc=technikum,dc=fh-joanneum,dc=local',
        'cn={username},ou=IMA,OU=Personal,OU=Benutzer,OU=Graz,OU=Technikum,dc=technikum,dc=fh-joanneum,dc=local',
        'cn={username},ou=GEB,OU=Personal,OU=Benutzer,OU=Graz,OU=Technikum,dc=technikum,dc=fh-joanneum,dc=local',
        'CN=kuberhub,CN=Users,DC=technikum,DC=fh-joanneum,DC=local'
      ]
      c.LDAPAuthenticator.user_search_base = 'ou=technikum,dc=technikum,dc=fh-joanneum,dc=local'
      c.LDAPAuthenticator.user_attribute = 'sAMAccountName'
      c.LDAPAuthenticator.escape_userdn = False

    01-image-selection: |
      c.KubeSpawner.environment = {'GRANT_SUDO': 'True'}

      def chooseImage(spawner):
        username = spawner.user.name
        userdn = os.environ.get(username)
        url = 'http://hub-info/Accounts_IMA18.json'
        students = requests.get(url=url).json()
        get_student = lambda username: list(filter(lambda s: s['username']==username,students))[0]
        logger.info('USERNAME:', username)
        logger.info('STUDENTS')
        logger.info(students)
        #logger.debug('INFO:', get_student(username))
        path_ima = '/tmp/exchange/ima/nbgrader_config.py'
        path_dat = '/tmp/exchange/dat/nbgrader_config.py'

        if('Personal' in userdn and 'IMA' in userdn):
            spawner.environment = {
                'NB_UID' : '2000',
                'TEACHER_GID' : '200',
                'CONFIGPATH': path_ima
            }
        if('IMA16' in userdn):
            spawner.environment = {
                'NB_UID' : '2001',
                'NB_GID' : '201',
                'CONFIGPATH': path_ima
            }
        elif('IMA18' in userdn):
             spawner.environment = {
                'NB_UID': '2001',
                'NB_GID': '201',
                'CONFIGPATH': f"/tmp/exchange/ima-grp{get_student(username)['group']}/nbgrader_config.py"
        }
        elif('kuberhub' in userdn):
            spawner.environment = {
                'NB_UID' : '2001',
                'NB_GID' : '201',
                'CONFIGPATH': path_ima
            }

        elif('DAT' in userdn and 'Personal' in userdn):
        #elif('grainerm15' in userdn):
            spawner.environment = {
                'NB_UID': '2000',
                'TEACHER_GID': '200',
                'CONFIGPATH': path_dat
            }

        #elif('DAT18' in userdn):
        elif('grainerm15' in userdn):
            spawner.environment = {
                'NB_UID': '2001',
                'NB_GID': '201',
                'CONFIGPATH': path_dat
            }

      def createProfileList(spawner):
        info2_golang_teacher =  {
                'display_name': 'INFO2 Golang Teacher Notebook',
                'default': False,
                'kubespawner_override': {
                  'image': 'fhjima/golang:latest',
                  'cmd': ['/usr/local/bin/start-notebook.sh'],
                  'cpu_guarantee': 0.5,
                  'cpu_limit': 1.5,
                  'mem_guarantee': '1G',
                  'mem_limit': '3G',
                  'uid':0,
                  'notebook_dir':'/home/jovyan/work'
                }
              }
        r_teacher =  {
                'display_name': 'R Teacher Notebook',
                'default': False,
                'kubespawner_override': {
                  'image': 'fhjima/teacher-r-notebook:latest',
                  'cmd': ['/usr/local/bin/start-notebook.sh'],
                  'cpu_guarantee': 0.5,
                  'cpu_limit': 1.5,
                  'mem_guarantee': '1G',
                  'mem_limit': '3G',
                  'uid':0,
                  'notebook_dir':'/home/jovyan/work'
                }
              }
        datascience_teacher =  {
                'display_name': 'Datascience Teacher Notebook',
                'default': False,
                'kubespawner_override': {
                  'image': 'fhjima/data_science_teacher:latest',
                  'cmd': ['/usr/local/bin/start-notebook.sh'],
                  'cpu_guarantee': 0.5,
                  'cpu_limit': 1.5,
                  'mem_guarantee': '1G',
                  'mem_limit': '3G',
                  'uid':0,
                  'notebook_dir':'/home/jovyan/work'
                }
              }
        info2_student = {
                'display_name': 'IMA/INFO2 Student Notebook',
                'default': True,
                'kubespawner_override': {
                  'image': 'skogelnik/kuberhub-student-image:latest',
                  'cpu_guarantee': 0.5,
                  'cpu_limit': 1.5,
                  'mem_guarantee': '1G',
                  'mem_limit': '2.8G',
                }
              }
        username = spawner.user.name
        info2_teachers = ["salho"]
        userdn = os.environ.get(username)
        list = []
        #if('Personal' in userdn and 'IMA' in userdn):
        if('IMA16' in userdn):
          spawner.environment = {
              'CONFIGPATH' : '/tmp/exchange/ima/nbgrader_config.py'
              }
          list = [info2_student]
        elif('IMA18' in userdn):
          list = [info2_student]
        elif(username in info2_teachers):
          list = [info2_golang_teacher,r_teacher, datascience_teacher]
        elif('kuberhub' in userdn):
          list = [
              {
                'display_name': 'IMA Student Notebook',
                'default': True,
                'kubespawner_override': {
                  'image': 'skogelnik/kuberhub-student-image:latest',
                  'cpu_guarantee': 0.5,
                  'cpu_limit': 1,
                  'mem_guarantee': '1G',
                  'mem_limit': '2G',
                }
              }
          ]
        #elif('PERSONAL' in userdn and 'DAT' in userdn):
        elif('kuberhub' in userdn):
          spawner.environment = {
              'CONFIGPATH' : '/tmp/exchange/dat/nbgrader_config.py'
            }
          list = [
              {
                'display_name': 'Teacher Notebook',
                'default': True,
                'kubespawner_override': {
                  'image': 'grainerm/teacher-datascience-notebook:latest',
                  'cpu_guarantee': 0.5,
                  'cpu_limit': 1,
                  'mem_guarantee': '1G',
                  'mem_limit': '2G',
                 }
              }
          ]

        elif('DAT18' in userdn):
          spawner.environment = {
              'CONFIGPATH' : '/tmp/exchange/dat/nbgrader_config.py'
            }
          list = [
              {
                'display_name': 'Teacher Notebook',
                'default': True,
                'kubespawner_override': {
                  'image': 'grainerm/student-datascience-notebook:latest',
                  'cpu_guarantee': 0.5,
                  'cpu_limit': 1,
                  'mem_guarantee': '1G',
                  'mem_limit': '2G',
                 }
              }
            ]
        return list

      c.KubeSpawner.pre_spawn_hook = chooseImage

      c.KubeSpawner.storage_capacity = '100M'

      c.KubeSpawner.start_timeout = 60 * 5

      c.KubeSpawner.profile_list = createProfileList

      c.KubeSpawner.cmd = ['/usr/local/bin/start.sh','jupyter','notebook']
    02-volumes: |
      c.KubeSpawner.volumes = [
        {
          'name': 'nbgrader',
          'persistentVolumeClaim': {
             'claimName': 'nbgradernew'
           }
        },
        {
          'name': 'users',
          'persistentVolumeClaim': {
             'claimName': 'claim-{username}'
           }
        }
      ]
      c.KubeSpawner.volume_mounts = [
        {
          'mountPath': '/tmp/exchange',
          'name': 'nbgrader'
        },
        {
          'mountPath': '/home/jovyan/work',
          'name': 'users'
        }
      ]
      c.KubeSpawner.http_timeout = 120

      c.KubeSpawner.cmd = ["/usr/local/bin/start.sh"]

      c.KubeSpawner.node_affinity_preferred = [
        {
          'weight': 50,
          'preference': {
            'matchExpressions': [
                {
                  'key': 'node-role.kubernetes.io/master',
                  'operator': 'DoesNotExist',
                  'values': []
                }
            ]
          }
        }
      ]
  extraConfigMap: {}
  extraEnv: {}
  extraContainers: []
  extraVolumes: []
  extraVolumeMounts: []
  image:
    name: fhjima/k8s-hub
    tag: 'latest'
  resources:
    requests:
      cpu: 200m
      memory: 512Mi
  services: {}
  imagePullPolicy: IfNotPresent
  imagePullSecret:
    enabled: false
    registry:
    username:
    email:
    password:
  pdb:
    enabled: true
    minAvailable: 1
  networkPolicy:
    enabled: false
    egress:
      - to:
          - ipBlock:
              cidr: 0.0.0.0/0
  allowNamedServers: false


rbac:
  enabled: true


proxy:
  secretToken: 'd05040282a1016decc0e23f1234329e2dc9934773abb3d1b6832626b8aa78f91'
  service:
    type: LoadBalancer
    labels: {}
    annotations: {}
    nodePorts:
      http:
      https:
    loadBalancerIP:
  chp:
    image:
      name: jupyterhub/configurable-http-proxy
      tag: 3.0.0
      pullPolicy: IfNotPresent
    resources:
      requests:
        cpu: 200m
        memory: 512Mi
  nginx:
    image:
      name: quay.io/kubernetes-ingress-controller/nginx-ingress-controller
      tag: 0.15.0
      pullPolicy: IfNotPresent
    proxyBodySize: 64m
    resources: {}
  lego:
    image:
      name: jetstack/kube-lego
      tag: 0.1.7
      pullPolicy: IfNotPresent
    resources: {}
  labels: {}
  nodeSelector: {}
  pdb:
    enabled: true
    minAvailable: 1
  https:
    enabled: true
    type: letsencrypt
    #type: letsencrypt, manual, offload, secret
    letsencrypt:
      contactEmail: ''
    manual:
      key:
      cert:
    secret:
      name: ''
      key: tls.key
      crt: tls.crt
    hosts: []
  networkPolicy:
    enabled: false
    egress:
      - to:
          - ipBlock:
              cidr: 0.0.0.0/0


auth:
  type: dummy
  whitelist:
    users:
  admin:
    access: true
    users:
  dummy:
    password:
  ldap:
    dn:
      search: {}
      user: {}
    user: {}
  state:
    enabled: false
    cryptoKey:


singleuser:
  extraTolerations: []
  nodeSelector: {}
  extraNodeAffinity:
    required: []
    preferred: []
  extraPodAffinity:
    required: []
    preferred: []
  extraPodAntiAffinity:
    required: []
    preferred: []
  networkTools:
    image:
      name: jupyterhub/k8s-network-tools
      tag: '0.8.2'
  cloudMetadata:
    enabled: false
    ip: 169.254.169.254
  networkPolicy:
    enabled: false
    egress:
    # Required egress is handled by other rules so it's safe to modify this
      - to:
          - ipBlock:
              cidr: 0.0.0.0/0
              except:
                - 169.254.169.254/32
  events: true
  extraAnnotations: {}
  extraLabels:
    hub.jupyter.org/network-access-hub: 'true'
  extraEnv: {}
  lifecycleHooks:
  initContainers: []
  extraContainers: []
  uid: 1000
  fsGid: 100
  serviceAccountName:
  storage:
    type: dynamic
    extraLabels: {}
    extraVolumes: []
    extraVolumeMounts: []
    static:
      pvcName:
      subPath: '{username}'
    capacity: 10Gi
    homeMountPath: /home/jovyan
    dynamic:
      storageClass:
      pvcNameTemplate: claim-{username}{servername}
      volumeNameTemplate: volume-{username}{servername}
      storageAccessModes: [ReadWriteOnce]
  image:
    name: jupyterhub/k8s-singleuser-sample
    tag: '0.8.2'
    pullPolicy: IfNotPresent
  imagePullSecret:
    enabled: false
    registry:
    username:
    email:
    password:
  startTimeout: 300
  cpu:
    limit:
    guarantee:
  memory:
    limit:
    guarantee: 1G
  extraResource:
    limits: {}
    guarantees: {}
  cmd: jupyterhub-singleuser
  defaultUrl:


scheduling:
  userScheduler:
    enabled: false
    replicas: 1
    logLevel: 4
    image:
      name: gcr.io/google_containers/kube-scheduler-amd64
      tag: v1.11.2
    nodeSelector: {}
    pdb:
      enabled: true
      minAvailable: 1
    resources:
      requests:
        cpu: 50m
        memory: 256Mi
  podPriority:
    enabled: false
    globalDefault: false
    defaultPriority: 0
    userPlaceholderPriority: -10
  userPlaceholder:
    enabled: true
    replicas: 0
  corePods:
    nodeAffinity:
      matchNodePurpose: prefer
  userPods:
    nodeAffinity:
      matchNodePurpose: prefer


prePuller:
  hook:
    enabled: true
    image:
      name: jupyterhub/k8s-image-awaiter
      tag: '0.8.2'
  continuous:
    enabled: false
  extraImages: {}
  pause:
    image:
      name: gcr.io/google_containers/pause
      tag: '3.0'


ingress:
  enabled: false
  annotations: {}
  hosts: []
  pathSuffix: ''
  tls: []


cull:
  enabled: true
  users: false
  timeout: 3600
  every: 600
  concurrency: 10
  maxAge: 0


debug:
  enabled: false
